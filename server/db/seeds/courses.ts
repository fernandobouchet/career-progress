export const coursesSeed = [
  {
    id: 1,
    name: "Matemática I",
    info: "Elementos de lógica proposicional: conectivos lógicos (negación, conjunción, disyunción, implicación, bicondicional), tablas de verdad, equivalencias lógicas y leyes de De Morgan. Lógica de predicados: cuantificadores universal y existencial, negación de cuantificadores, ejemplos de formalización de enunciados. Teoría básica de conjuntos: definición de conjunto, operaciones (unión, intersección, diferencia, complemento), producto cartesiano, relaciones binarias (reflexivas, simétricas, transitivas), relaciones de equivalencia y particiones. Funciones: definición, inyectividad, sobreyectividad, biyectividad, composición de funciones, funciones inversas. Principio de inducción matemática: demostraciones por inducción sobre números naturales, ejemplos de aplicación en sumatorias y desigualdades. Estructuras discretas: introducción a grafos (definición, tipos: dirigidos y no dirigidos, representación matricial), árboles y sus propiedades. Elementos básicos de análisis combinatorio: principio de conteo, permutaciones, combinaciones, binomial de Newton.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 8,
    hsTotal: 128,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 2,
    name: "Introducción a la Programación",
    info: "Introducción a los conceptos fundamentales de la programación: qué es un programa, diferencias entre hardware y software, roles del programador. Entornos de desarrollo y ejecución: uso de IDEs, compiladores e intérpretes. Paradigmas de programación: descripción de los paradigmas imperativo, orientado a objetos, funcional y lógico, con ejemplos introductorios. Principios de la programación imperativa: acciones y comandos (asignación, entrada/salida), valores y expresiones (aritméticas, lógicas), tipos de datos básicos (enteros, reales, booleanos, caracteres), variables y estado del programa. Estructuras de control: secuencia, selección (if, switch), iteración (while, for). Introducción a la programación estructurada: funciones y procedimientos, paso de parámetros por valor y referencia, ámbito de variables. Resolución de problemas: metodología para descomponer problemas en subproblemas, diseño de algoritmos simples (búsqueda, ordenamiento básico). Estructuras de datos básicas: arreglos unidimensionales, registros (structs), ejemplos de uso en problemas prácticos.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 8,
    hsTotal: 128,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 3,
    name: "Organización de Computadoras",
    info: "Conceptos básicos de la arquitectura de computadoras: modelo de Von Neumann, componentes principales (CPU, memoria, dispositivos de entrada/salida). Representación de la información: sistemas de numeración (binario, octal, hexadecimal), conversión entre bases, representación de números enteros (signo-magnitud, complemento a dos), números en punto flotante (IEEE 754), códigos alfanuméricos (ASCII, Unicode). Aritmética computacional: operaciones binarias (suma, resta, multiplicación, división), detección y corrección de errores numéricos. Lógica digital: puertas lógicas (AND, OR, NOT, NAND, NOR, XOR), tablas de verdad, diseño de circuitos combinatorios (sumadores, multiplexores), circuitos secuenciales (flip-flops, registros). Lenguaje ensamblador: estructura de instrucciones, registros, direccionamiento, ejemplos de programas simples. Organización funcional: unidad central de procesamiento (ALU, registros, unidad de control), ciclo de instrucción (fetch-decode-execute), memoria principal (RAM, ROM), jerarquía de memoria (caché, memoria virtual), subsistema de entrada/salida (interrupciones, DMA).",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 4,
    name: "Nuevos Entornos y Lenguajes",
    info: "Introducción a la producción de conocimiento en la era digital: evolución de la Web (1.0, 2.0, 3.0), características de la cultura digital, impacto de las tecnologías en la comunicación y el aprendizaje. Lectura y escritura en la nube: conceptos de hipertextualidad e hipermedialidad, uso de herramientas colaborativas (Google Docs, wikis), análisis de textos digitales. Búsqueda de información: criterios para evaluar fuentes (confiabilidad, relevancia), uso de motores de búsqueda avanzados, interpretación crítica de resultados. Escritura colaborativa: dinámicas de trabajo en equipo en entornos digitales, plataformas de edición en tiempo real. Nuevas formas de producir conocimiento: redes sociales como espacios de intercambio, comunidades de práctica virtuales, inteligencia colectiva y crowdsourcing. Lenguaje audiovisual: elementos básicos de producción (guion, edición), interpretación de narrativas audiovisuales. Narrativas transmedia: convergencia de formatos (texto, video, audio), ejemplos de storytelling multiplataforma. Convergencia tecnológica: integración de dispositivos y servicios digitales.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 5,
    name: "Estructuras de Datos",
    info: "Introducción a los tipos abstractos de datos: definición, especificación, implementación. Recursión: definición, ejemplos en listas y árboles, análisis de eficiencia. Estructuras lineales: pilas (stack), colas (queue), colas de prioridad, implementación con arreglos y listas enlazadas, operaciones (push, pop, enqueue, dequeue). Estructuras de datos dinámicas: listas enlazadas simples y dobles, nodos, punteros, inserción, eliminación y recorrido. Árboles: definición, árboles binarios, árboles de búsqueda binaria (BST), árboles balanceados (AVL), operaciones de inserción, búsqueda y eliminación. Tablas hash: funciones hash, manejo de colisiones (encadenamiento, direccionamiento abierto), análisis de rendimiento. Algoritmos asociados: recorrido de estructuras (preorden, inorden, postorden), búsqueda lineal y binaria, ordenamiento básico (burbuja, inserción, selección). Representación en memoria: modelo de memoria imperativa (stack/heap), alocación dinámica, punteros y referencias. Análisis de eficiencia: notación Big-O, comparación de estructuras en términos de tiempo y espacio.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 8,
    hsTotal: 128,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 6,
    name: "Programación con Objetos I",
    info: "Introducción al paradigma orientado a objetos: conceptos fundamentales (objeto, mensaje, clase), diferencias con programación imperativa. Polimorfismo: definición, ventajas, ejemplos de uso en diseño de software. Encapsulamiento: atributos privados, métodos públicos, getters y setters, principios de diseño. Herencia: jerarquías de clases, herencia simple, redefinición de métodos (override), method lookup. Interfaz y protocolo: definición de interfaces, implementación en clases, contratos entre objetos. Estado en objetos: referencias entre objetos, estado interno, ciclo de vida de un objeto. Colecciones: uso de colecciones como objetos (listas, conjuntos, diccionarios), protocolo de acceso (iteración, inserción, eliminación). Diseño básico orientado a objetos: principios de responsabilidad única, delegación de tareas. Testing: introducción al testeo automático (unit testing), herramientas básicas (JUnit, pytest). Manejo de errores: excepciones, estructuras de control para interrupción de flujo, buenas prácticas en manejo de errores.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 8,
    hsTotal: 128,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 7,
    name: "Bases de Datos",
    info: "Introducción a los sistemas de bases de datos: definición, diferencias con sistemas de archivos, ventajas y desventajas. Modelos de datos: modelo conceptual (entidad-relación: entidades, atributos, relaciones, cardinalidad), modelo lógico (relacional: tablas, claves primarias y foráneas, integridad referencial), modelo físico (almacenamiento en disco). Lenguaje SQL: sintaxis básica (CREATE, INSERT, UPDATE, DELETE, SELECT), consultas simples y con condiciones (WHERE), ordenamiento (ORDER BY), funciones de agregación (COUNT, SUM, AVG, MAX, MIN), agrupamientos (GROUP BY, HAVING). Operaciones relacionales: joins (INNER, LEFT, RIGHT, FULL), subconsultas, vistas. Diseño de bases de datos: normalización (1NF, 2NF, 3NF), desnormalización para rendimiento. Administración de bases de datos: usuarios, permisos, índices para optimización, backups y recuperación. Transacciones: propiedades ACID, demarcación (BEGIN, COMMIT, ROLLBACK), concurrencia y bloqueos.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 8,
    name: "Inglés I",
    info: "Introducción a la lectura y comprensión de textos auténticos en inglés relacionados con informática y tecnología: artículos técnicos, manuales, documentación de software. Estrategias de lectura: identificación de palabras clave, palabras transparentes (cognados), palabras repetidas, uso de índices tipográficos (títulos, subtítulos, negritas). Organización textual: identificación del tema principal, despliegue temático, párrafos de introducción y conclusión. Técnicas de lectura rápida: skimming (lectura superficial para idea general), scanning (búsqueda de información específica). Cohesión y coherencia: conectores lógicos (and, but, because, therefore), referentes contextuales (anáforas, catáforas), elipsis. Morfología: prefijos y sufijos comunes en inglés técnico (un-, re-, -tion, -able). Categorías gramaticales: sustantivos, verbos, adjetivos, adverbios. Estructura de definiciones: definición de conceptos técnicos, objetos y procesos. Uso del gerundio (-ing) y participio pasado (-ed) en descripciones técnicas. Relaciones lógicas: adición, contraste, causa-efecto, enumeración.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 9,
    name: "Matemática II",
    info: "Introducción a los espacios vectoriales: definición, subespacios, combinaciones lineales, independencia lineal, base y dimensión de un espacio vectorial. Transformaciones lineales: definición, propiedades (linealidad), núcleo e imagen, representación matricial de transformaciones, composición de transformaciones. Matrices: operaciones (suma, producto, transposición), propiedades (determinante, inversa), resolución de sistemas de ecuaciones lineales mediante eliminación gaussiana y regla de Cramer. Determinantes: definición, cálculo (método de cofactores), propiedades (efecto de operaciones elementales), aplicaciones en sistemas lineales. Espacios con producto interior: definición, norma, ortogonalidad, proyecciones ortogonales, método de cuadrados mínimos para ajuste de datos.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 10,
    name: "Programación con Objetos II",
    info: "Conceptos avanzados del paradigma orientado a objetos: herencia múltiple (simulación en lenguajes sin soporte nativo), mixins y traits como alternativas a herencia, interfaces múltiples y su implementación. Diseño orientado a objetos: principios SOLID (responsabilidad única, abierto/cerrado, sustitución de Liskov, segregación de interfaces, inversión de dependencias), patrones de diseño fundamentales (factory method, singleton, observer, adapter). Polimorfismo avanzado: polimorfismo paramétrico, uso de reflexión para inspección dinámica de objetos. Programación genérica: definición de tipos parametrizados (generics), restricciones de tipo, ventajas en reutilización y seguridad de tipos. Manejo avanzado de excepciones: jerarquía de excepciones, creación de excepciones personalizadas, propagación y captura múltiple. Colecciones avanzadas: implementación de estructuras como mapas, conjuntos y listas, iteradores y streams.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 11,
    name: "Redes de Computadoras",
    info: "Introducción a las redes de computadoras: definición, clasificación (LAN, WAN, MAN), topologías (estrella, bus, anillo). Modelos de referencia: modelo OSI (capas física, enlace, red, transporte, sesión, presentación, aplicación), modelo TCP/IP (enlace, internet, transporte, aplicación). Capa física: medios de transmisión (cables de cobre, fibra óptica, inalámbricos), señales analógicas y digitales, codificación (Manchester, NRZ). Capa de enlace: protocolos (Ethernet, PPP), control de acceso al medio (CSMA/CD, CSMA/CA), direccionamiento MAC, switches y bridges. Capa de red: direccionamiento IP (IPv4, IPv6), subnetting, enrutamiento básico (tablas de enrutamiento, RIP), protocolos (IP, ICMP). Capa de transporte: TCP (control de flujo, congestión, establecimiento de conexión), UDP (características, usos). Herramientas de diagnóstico: ping, traceroute, análisis de paquetes con Wireshark.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 12,
    name: "Sistemas Operativos",
    info: "Conceptos fundamentales de sistemas operativos: definición, funciones (gestión de recursos, abstracción de hardware), tipos (monotarea, multitarea, monousuario, multiusuario). Estructura de un SO: núcleo (kernel monolítico, microkernel), interfaces (shell, API). Gestión de procesos: estados del proceso (nuevo, listo, ejecutando, bloqueado, terminado), planificación de procesos (FIFO, SJF, Round Robin), creación y terminación de procesos (fork, exec). Concurrencia: problemas de sincronización (condición de carrera), mecanismos (semáforos, monitores, mutex), deadlocks (detección, prevención). Gestión de memoria: particionamiento, paginación, segmentación, memoria virtual (tablas de páginas, TLB). Sistemas de archivos: estructura (directorios, inodos), implementación (FAT, NTFS, ext4), operaciones (lectura, escritura, montaje). Entrada/Salida: principios de hardware (controladores, interrupciones), gestión de dispositivos (buffering, spooling).",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 13,
    name: "Programación Funcional",
    info: "Introducción al paradigma funcional: principios básicos (funciones puras, inmutabilidad, ausencia de efectos secundarios), diferencias con paradigmas imperativos y orientados a objetos. Evaluación de expresiones: evaluación estricta vs. perezosa (lazy evaluation), ventajas y ejemplos en lenguajes como Haskell. Funciones de orden superior: definición, aplicación (map, filter, reduce), composición de funciones, funciones lambda. Tipos de datos algebraicos: tipos suma (either, maybe), tipos producto (tuplas, registros), tipos enumerativos, listas y árboles como tipos recursivos. Pattern matching: definición, uso en descomposición de estructuras, ejemplos en lenguajes funcionales. Recursión: recursión estructural sobre listas y árboles, optimización con recursión de cola. Monadas: concepto, leyes de las monadas, ejemplos (Maybe, IO, State), uso para manejar efectos secundarios en lenguajes puros. Implementación práctica: programación funcional en lenguajes como Haskell o Scala, resolución de problemas clásicos (factorial, Fibonacci, quicksort funcional).",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 14,
    name: "Construcción de Interfaces de Usuario",
    info: "Introducción al diseño de interfaces de usuario: conceptos de usabilidad, accesibilidad, experiencia de usuario (UX). Principios de diseño: consistencia, feedback, affordance, modelos mentales del usuario. Prototipado: herramientas (Figma, Adobe XD), creación de wireframes y mockups. Tecnologías frontend: HTML (estructura semántica, formularios), CSS (estilos, flexbox, grid, responsive design), JavaScript (manipulación del DOM, eventos). Frameworks de UI: introducción a React, Vue o Angular, componentes reutilizables, estado y props. Interacción usuario-sistema: manejo de eventos (clics, teclado), validación de formularios, animaciones básicas. Diseño centrado en el usuario: metodologías (entrevistas, pruebas de usabilidad), iteración basada en retroalimentación. Accesibilidad: estándares WAI-ARIA, diseño inclusivo para personas con discapacidades. Integración con backend: consumo de APIs REST, manejo de datos dinámicos.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 15,
    name: "Algoritmos",
    info: "Introducción al diseño y análisis de algoritmos: definición de algoritmo, propiedades (finitud, determinismo, efectividad), ejemplos básicos. Técnicas de diseño: divide y conquista (mergesort, quicksort), programación dinámica (Fibonacci, mochila), algoritmos voraces (Kruskal, Prim). Análisis de complejidad: notación asintótica (Big-O, Omega, Theta), análisis de tiempo y espacio, casos promedio y peor caso. Algoritmos de búsqueda: búsqueda lineal, búsqueda binaria, análisis comparativo. Algoritmos de ordenamiento: burbuja, inserción, selección, mergesort, quicksort, heapsort, estabilidad y rendimiento. Estructuras de datos avanzadas: árboles de búsqueda binaria, heaps, grafos (representación con matrices y listas de adyacencia). Algoritmos sobre grafos: búsqueda en profundidad (DFS), búsqueda en amplitud (BFS), caminos mínimos (Dijkstra). Problemas clásicos: torres de Hanoi, problema del viajante (TSP), ejemplos de implementación.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 16,
    name: "Estrategias de Persistencia",
    info: "Introducción a la persistencia de datos: definición, diferencias entre almacenamiento volátil y persistente, importancia en sistemas de software. Modelos de persistencia: bases de datos relacionales (estructura, normalización), bases NoSQL (clave-valor, documentos, columnas, grafos). Mapeo objeto-relacional (ORM): conceptos de ORM, frameworks (Hibernate, Entity Framework, SQLAlchemy), mapeo de clases a tablas, relaciones (uno a muchos, muchos a muchos). Consultas avanzadas en SQL: joins complejos, subconsultas correlacionadas, índices para optimización, vistas materializadas. Persistencia en bases NoSQL: características (escalabilidad, flexibilidad), ejemplos (MongoDB, Cassandra), diseño de esquemas. Estrategias de acceso a datos: patrones (DAO, Repository), caching (Redis, Memcached), manejo de transacciones distribuidas. Rendimiento y escalabilidad: particionamiento, sharding, replicación, consistencia vs. disponibilidad (teorema CAP). Buenas prácticas: manejo de conexiones, prevención de inyección SQL, auditoría de datos.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 17,
    name: "Laboratorio de Sistemas Operativos y Redes",
    info: "Introducción práctica a sistemas operativos y redes: configuración y administración de sistemas Linux/Windows. Gestión de procesos: uso de comandos (ps, top, taskmgr), creación de scripts para automatización, monitoreo de recursos. Configuración de redes: asignación de direcciones IP estáticas y dinámicas (DHCP), configuración de máscaras de subred, gateways. Protocolos de red: análisis de paquetes con Wireshark, configuración de servicios (DNS, HTTP), uso de herramientas (ping, traceroute, netstat). Seguridad básica: configuración de firewalls (iptables, Windows Firewall), permisos de usuario, cifrado de comunicaciones. Virtualización: introducción a máquinas virtuales (VirtualBox, VMware), creación y gestión de VMs. Prácticas de laboratorio: instalación de SO, configuración de redes locales, resolución de problemas de conectividad, simulación de ataques básicos (escaneo de puertos). Documentación: redacción de informes técnicos sobre configuraciones realizadas.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 18,
    name: "Análisis Matemático",
    info: "Introducción al cálculo diferencial e integral: conceptos de límite, continuidad, propiedades de funciones continuas. Derivadas: definición, reglas de derivación (producto, cociente, cadena), derivadas de funciones trigonométricas, logarítmicas y exponenciales, aplicaciones (máximos, mínimos, puntos de inflexión). Integrales: integral definida e indefinida, teorema fundamental del cálculo, métodos de integración (sustitución, por partes, fracciones parciales). Series numéricas: convergencia y divergencia, criterios (comparación, razón, raíz), series geométricas y armónicas. Funciones de varias variables: derivadas parciales, gradiente, matriz hessiana, optimización con restricciones (multiplicadores de Lagrange). Aplicaciones: cálculo de áreas, volúmenes, longitud de curvas, modelado matemático en problemas físicos e informáticos.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 19,
    name: "Lógica y Programación",
    info: "Fundamentos de lógica formal: lógica proposicional (conectivos, tablas de verdad, formas normales), lógica de primer orden (cuantificadores, predicados, modelos). Técnicas de demostración: deducción natural, demostración por contradicción, demostración directa, ejemplos en matemática e informática. Programación lógica: introducción al paradigma lógico, sintaxis de Prolog (hechos, reglas, consultas), unificación y resolución. Búsqueda en espacios de estados: backtracking, árboles de búsqueda, optimización con poda. Aplicaciones: resolución de problemas lógicos (sudoku, 8 reinas), sistemas expertos básicos, razonamiento automático. Relación con otros paradigmas: comparación con programación funcional e imperativa, ventajas en problemas de inteligencia artificial. Implementación práctica: escritura de programas en Prolog, integración con lenguajes imperativos.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 20,
    name: "Elementos de Ingeniería de Software",
    info: "Introducción a la ingeniería de software: definición, objetivos, diferencias con programación ad-hoc. Ciclo de vida del software: modelos clásicos (cascada, espiral), modelos iterativos (prototipado, incremental), metodologías ágiles (Scrum, XP). Requerimientos: elicitación (entrevistas, encuestas), especificación (casos de uso, historias de usuario), validación (revisiones, prototipos). Diseño de software: conceptos de arquitectura, diagramas UML (clases, secuencia, casos de uso), principios de diseño modular (cohesión, acoplamiento). Pruebas de software: tipos (unitarias, integración, sistema), estrategias (caja negra, caja blanca), herramientas de automatización (JUnit, Selenium). Gestión de configuración: control de versiones (Git), integración continua. Documentación: redacción de especificaciones técnicas, manuales de usuario. Ética en ingeniería de software: responsabilidad profesional, calidad del producto.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 21,
    name: "Seguridad de la Información",
    info: "Introducción a la seguridad informática: definición, importancia, diferencia entre seguridad de la información y ciberseguridad. Amenazas y vulnerabilidades: tipos de ataques (malware, phishing, DDoS), análisis de riesgos, evaluación de impacto. Criptografía: fundamentos (cifrado simétrico: AES, DES; cifrado asimétrico: RSA, claves públicas/privadas), funciones hash (MD5, SHA), firmas digitales. Seguridad en redes: protocolos seguros (SSL/TLS, IPsec), configuración de firewalls, detección de intrusos (IDS). Seguridad en sistemas operativos: gestión de permisos, autenticación (contraseñas, multifactor), auditoría de seguridad. Políticas de seguridad: diseño de políticas, cumplimiento normativo (ISO 27001), planes de respuesta a incidentes. Prácticas de laboratorio: cifrado de mensajes, análisis de vulnerabilidades con herramientas (Nmap, Metasploit), configuración de VPNs.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 22,
    name: "Materia UNAHUR I",
    info: "Materia específica diseñada por la Universidad Nacional de Hurlingham para complementar la formación en informática. Contenidos variables según el ciclo lectivo: puede incluir temas de actualidad tecnológica, interdisciplinariedad o problemáticas sociales relacionadas con la informática. Ejemplos posibles: introducción a la ética digital, fundamentos de robótica, o historia de la informática. Actividades prácticas: análisis de casos, debates, trabajos grupales. Evaluación: presentación de proyectos o informes escritos.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 23,
    name: "Inglés II",
    info: "Desarrollo de habilidades avanzadas en lectura y escritura técnica en inglés: comprensión de textos complejos (artículos científicos, white papers, documentación técnica avanzada). Estrategias de lectura: inferencia de significados por contexto, deducción de términos técnicos, análisis crítico de contenido. Vocabulario técnico: términos específicos de informática (networking, algorithms, software engineering), construcción de glosarios. Escritura técnica: redacción de resúmenes, informes técnicos breves, correos profesionales en inglés. Introducción a la escucha: comprensión de charlas técnicas (podcasts, conferencias TED), identificación de ideas principales y detalles. Gramática avanzada: tiempos verbales compuestos (present perfect, past perfect), voz pasiva en descripciones técnicas, oraciones condicionales. Práctica oral: exposición de temas técnicos en inglés, debates sobre tecnología. Uso de herramientas: traducción asistida, diccionarios técnicos online.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 24,
    name: "Matemática III",
    info: "Ecuaciones diferenciales ordinarias: definición, clasificación (lineales, no lineales), métodos de resolución (separación de variables, factores integrantes), aplicaciones en modelado (crecimiento poblacional, circuitos). Transformadas: transformada de Laplace (definición, propiedades, resolución de ecuaciones diferenciales), transformada de Fourier (análisis de señales, aplicaciones en informática). Optimización: funciones de varias variables, gradiente, Hessiano, extremos con restricciones (multiplicadores de Lagrange), aplicaciones en machine learning y algoritmos. Series de potencias: convergencia, radio de convergencia, desarrollo en series de Taylor y Maclaurin. Análisis numérico introductorio: aproximación de soluciones (método de Euler), errores de redondeo y truncamiento.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 25,
    name: "Programación Concurrente",
    info: "Introducción a la programación concurrente: definición, diferencias con programación secuencial, aplicaciones (multitarea, servidores). Modelos de concurrencia: hilos (threads), procesos, actores, memoria compartida vs. paso de mensajes. Gestión de hilos: creación y terminación (Java Threads, POSIX threads), estados de los hilos, prioridades. Sincronización: problemas clásicos (sección crítica, productor-consumidor), mecanismos (locks, semáforos, monitores), condiciones de carrera y su prevención. Deadlocks: definición, condiciones necesarias, detección y resolución (algoritmo del banquero). Herramientas y lenguajes: uso de bibliotecas (Java Concurrency, pthreads), introducción a lenguajes concurrentes (Go, Erlang). Análisis de rendimiento: overhead de concurrencia, escalabilidad, profiling de aplicaciones concurrentes. Prácticas: implementación de problemas concurrentes (buffer circular, lectores-escritores).",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 26,
    name: "Ingeniería de Requerimientos",
    info: "Introducción a la ingeniería de requerimientos: definición, importancia en el desarrollo de software, rol del ingeniero de requerimientos. Elicitación de requerimientos: técnicas (entrevistas, cuestionarios, observación, brainstorming), identificación de stakeholders, análisis de necesidades. Especificación de requerimientos: redacción de documentos (SRS), formatos (historias de usuario, casos de uso), requisitos funcionales y no funcionales (rendimiento, seguridad, usabilidad). Validación de requerimientos: revisiones formales, prototipos, pruebas de aceptación, trazabilidad. Gestión de requerimientos: herramientas (JIRA, Trello), manejo de cambios, priorización (MoSCoW, Kano). Problemas comunes: ambigüedad, incompletitud, conflictos entre stakeholders, técnicas de resolución. Relación con otros procesos: integración con diseño y pruebas. Prácticas: elaboración de un documento de requerimientos para un proyecto pequeño.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 27,
    name: "Desarrollo de Aplicaciones",
    info: "Introducción al desarrollo full-stack: definición, arquitectura cliente-servidor, tecnologías involucradas. Backend: diseño de APIs REST (endpoints, métodos HTTP, códigos de estado), frameworks (Spring, Express.js, Django), autenticación (JWT, OAuth). Frontend: desarrollo de interfaces dinámicas (React, Angular), manejo de estado (Redux, Vuex), integración con APIs. Bases de datos: diseño de esquemas relacionales y NoSQL, consultas avanzadas, optimización. Integración: comunicación frontend-backend, manejo de errores, validación de datos. Despliegue: conceptos de DevOps (CI/CD), uso de contenedores (Docker), alojamiento (AWS, Heroku). Metodologías ágiles: aplicación de Scrum en desarrollo, sprints, retrospectivas. Proyecto práctico: desarrollo de una aplicación completa (ejemplo: sistema de gestión de tareas), desde diseño hasta despliegue.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 28,
    name: "Probabilidad y Estadística",
    info: "Introducción a la teoría de probabilidad: definición, espacio muestral, eventos, axiomas de probabilidad, probabilidad condicional, teorema de Bayes. Variables aleatorias: discretas (binomial, Poisson), continuas (normal, exponencial), funciones de distribución y densidad, valor esperado, varianza. Distribuciones: propiedades, aplicaciones en informática (tiempos de respuesta, fallos de sistemas). Estadística descriptiva: medidas de tendencia central (media, mediana, moda), medidas de dispersión (varianza, desviación estándar), representación gráfica (histogramas, boxplots). Inferencia estadística: estimación puntual e intervalos de confianza, pruebas de hipótesis (t-test, chi-cuadrado), nivel de significancia. Regresión: regresión lineal simple, método de mínimos cuadrados, correlación. Aplicaciones: análisis de datos en software, predicción de rendimiento, evaluación de algoritmos.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 29,
    name: "Gestión de Proyectos de Desarrollo de Software",
    info: "Introducción a la gestión de proyectos: definición, objetivos, ciclo de vida de un proyecto (inicio, planificación, ejecución, monitoreo, cierre). Metodologías: PMBOK (áreas de conocimiento: alcance, tiempo, costo, calidad, riesgos), Scrum (roles, artefactos, eventos), comparación con enfoques tradicionales. Planificación: definición de alcance, estructura de desglose del trabajo (WBS), cronogramas (diagramas de Gantt, PERT), asignación de recursos. Estimación: técnicas (puntos de función, COCOMO, estimación por analogía), manejo de incertidumbre. Gestión de riesgos: identificación, análisis cualitativo y cuantitativo, estrategias de mitigación. Herramientas: software de gestión (MS Project, Jira), control de versiones (Git). Monitoreo y control: métricas (velocidad, burndown), reuniones de seguimiento, ajustes al plan. Cierre: entrega del producto, documentación final, lecciones aprendidas. Prácticas: simulación de un proyecto de software en equipo.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 30,
    name: "Lenguajes Formales y Autómatas",
    info: "Introducción a la teoría de lenguajes formales: definición de lenguaje, alfabeto, cadenas, gramáticas. Autómatas finitos: determinísticos (DFA) y no determinísticos (NFA), equivalencia entre DFA y NFA, conversión, aplicaciones (expresiones regulares). Expresiones regulares: sintaxis, propiedades, conversión a autómatas, uso en búsqueda de patrones. Lenguajes regulares: propiedades de cierre, lema de bombeo para lenguajes regulares. Gramáticas: jerarquía de Chomsky (tipo 0, 1, 2, 3), gramáticas libres de contexto, árboles de derivación. Autómatas de pila: definición, lenguajes aceptados, ejemplos (balanceo de paréntesis). Máquinas de Turing: definición, componentes (cinta, cabezal, estados), variantes (multicinta, no determinística), ejemplos de diseño. Aplicaciones: compiladores, verificación de sistemas, fundamentos de computabilidad.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 31,
    name: "Programación con Objetos III",
    info: "Conceptos avanzados de diseño orientado a objetos: principios SOLID aplicados en profundidad, patrones de diseño estructurales (composite, decorator, facade) y de comportamiento (strategy, command, state). Reflexión: introspección de clases y objetos, uso en frameworks (Java Reflection, Python inspect). Metaprogramación: generación dinámica de código, decoradores, metaclasses. Arquitectura de software orientada a objetos: diseño de sistemas modulares, inyección de dependencias, contenedores IoC (Spring, Guice). Programación reactiva: introducción a flujos reactivos (RxJava, Reactive Streams), manejo de eventos asíncronos. Optimización de código: profiling de aplicaciones OO, detección de cuellos de botella, refactoring avanzado. Prácticas: desarrollo de un sistema complejo (ejemplo: simulador de eventos) usando patrones y herramientas modernas.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 32,
    name: "Materia UNAHUR II",
    info: "Segunda materia específica diseñada por la Universidad Nacional de Hurlingham para enriquecer la formación en informática. Contenidos variables según el ciclo lectivo: puede abordar temas como sostenibilidad tecnológica, inteligencia artificial ética, o programación para dispositivos emergentes. Actividades prácticas: desarrollo de proyectos interdisciplinarios, análisis de impacto tecnológico en la sociedad. Evaluación: presentación oral de proyectos, ensayos reflexivos. Enfoque en habilidades transversales: pensamiento crítico, trabajo colaborativo, comunicación efectiva.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 33,
    name: "Práctica Profesional Supervisada (PPS)",
    info: "Introducción a la práctica profesional: objetivos, importancia de la vinculación con el entorno laboral, roles del estudiante y supervisor. Desarrollo de un proyecto real: identificación de un problema en un contexto profesional (empresa, institución, comunidad), análisis de requerimientos, diseño de una solución tecnológica. Metodología de trabajo: aplicación de conocimientos adquiridos (programación, bases de datos, redes), uso de herramientas modernas (Git, Docker, frameworks). Documentación: redacción de un informe técnico detallado (planteo del problema, solución propuesta, implementación, resultados), diagramas y manuales de uso. Presentación: exposición oral del proyecto ante un tribunal, defensa de decisiones técnicas y metodológicas. Evaluación: cumplimiento de objetivos, calidad de la solución, impacto en el entorno. Reflexión: análisis de aprendizajes, desafíos enfrentados, propuestas de mejora.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 34,
    name: "Teoría de la Computación",
    info: "Introducción a la computabilidad: definición, problemas decidibles e indecidibles, máquina de Turing como modelo universal. Modelos de cómputo: autómatas finitos, autómatas de pila, máquinas de Turing (determinísticas, no determinísticas, multicinta), equivalencia entre modelos. Lenguajes y gramáticas: lenguajes regulares, libres de contexto, sensibles al contexto, irrestringidos, lemas de bombeo para cada tipo. Computabilidad: tesis de Church-Turing, problema de la parada (halting problem), reducción y problemas indecidibles. Complejidad computacional: clases P, NP, NP-completo, ejemplos (SAT, TSP), teorema de Cook-Levin. Reducciones: uso de reducciones para probar NP-completitud, ejemplos prácticos. Aplicaciones: fundamentos teóricos de compiladores, verificación formal, límites de la computación.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 35,
    name: "Arquitectura de Software I",
    info: "Introducción a la arquitectura de software: definición, importancia, diferencia con diseño detallado. Estilos arquitectónicos: monolítico, cliente-servidor, en capas, orientado a servicios (SOA), microservicios, ventajas y desventajas de cada uno. Principios de diseño: modularidad (cohesión, acoplamiento), separación de responsabilidades, extensibilidad. Patrones arquitectónicos: MVC, publish-subscribe, event-driven, ejemplos de implementación. Documentación: vistas arquitectónicas (4+1), diagramas UML (despliegue, componentes), descripción de decisiones arquitectónicas. Herramientas: frameworks para microservicios (Spring Boot, Flask), middleware (RabbitMQ, Kafka). Calidad: atributos de calidad (escalabilidad, mantenibilidad, rendimiento), métricas para evaluación. Prácticas: diseño de una arquitectura para un sistema distribuido pequeño (ejemplo: aplicación de mensajería).",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 36,
    name: "Sistemas Distribuidos y Tiempo Real",
    info: "Introducción a los sistemas distribuidos: definición, características (ausencia de reloj global, concurrencia, fallos independientes), aplicaciones (cloud computing, blockchain). Modelos: cliente-servidor, peer-to-peer, arquitecturas basadas en eventos. Comunicación: protocolos (RPC, mensajería), middleware (CORBA, gRPC), serialización (JSON, Protobuf). Sincronización: relojes lógicos (Lamport, vectoriales), algoritmos de exclusión mutua distribuida. Consenso: algoritmos (Paxos, Raft), tolerancia a fallos (replicación, consistencia eventual). Sistemas de tiempo real: definición, tipos (duro, blando), planificación (Rate Monotonic, EDF), ejemplos (sistemas embebidos). Diseño: especificación de requisitos temporales, manejo de latencia, verificación de cumplimiento. Prácticas: implementación de un sistema distribuido simple (ejemplo: chat P2P) y un sistema de tiempo real (controlador básico).",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 37,
    name: "Tesina de Licenciatura",
    info: "Desarrollo de un proyecto integrador o tesis como culminación de la carrera: elección de un tema de investigación o desarrollo tecnológico relevante en informática. Fases del proyecto: definición del problema, revisión bibliográfica, planteo de objetivos, diseño de la solución (metodología, herramientas, tecnologías). Implementación: desarrollo práctico de un prototipo, sistema o análisis teórico, uso de técnicas aprendidas (programación, bases de datos, redes). Documentación: redacción de un trabajo escrito detallado (introducción, marco teórico, metodología, resultados, conclusiones), uso de normas académicas (APA, IEEE). Presentación: defensa oral ante un tribunal, exposición de 20-30 minutos, respuesta a preguntas y críticas. Evaluación: originalidad, profundidad técnica, calidad de la implementación, claridad en la comunicación. Reflexión: análisis del impacto del proyecto, posibles mejoras, aprendizajes adquiridos.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 5,
    hsTotal: 160,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 38,
    name: "Características de Lenguajes de Programación",
    info: "Introducción al estudio de lenguajes de programación: definición, evolución histórica (máquina, ensamblador, alto nivel), clasificación (imperativos, funcionales, lógicos, orientados a objetos). Sintaxis y semántica: gramáticas formales, análisis sintáctico, semántica operacional, denotacional y axiomática. Tipado: sistemas de tipos (estático, dinámico, fuerte, débil), inferencia de tipos, polimorfismo de tipos. Gestión de memoria: asignación estática, dinámica, recolector de basura (mark-and-sweep, referencia counting). Concurrencia: modelos soportados (hilos, actores, CSP), ejemplos en lenguajes (Java, Erlang, Go). Paradigmas específicos: características de lenguajes funcionales (Haskell), lógicos (Prolog), orientados a objetos (Smalltalk). Evaluación de lenguajes: criterios (legibilidad, expresividad, eficiencia), comparación práctica (C vs. Python). Prácticas: análisis de fragmentos de código en distintos lenguajes, implementación de un problema en múltiples paradigmas.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 39,
    name: "Arquitectura de Software II",
    info: "Conceptos avanzados de arquitectura de software: diseño de sistemas a gran escala, arquitecturas cloud-native, serverless computing. Patrones avanzados: CQRS (Command Query Responsibility Segregation), Domain-Driven Design (DDD), event sourcing, ejemplos de implementación. Escalabilidad: estrategias horizontales y verticales, balanceo de carga, sharding, caching distribuido (Redis). Tolerancia a fallos: diseño resiliente, circuit breakers, retry patterns, caos engineering. Monitoreo y observabilidad: métricas (latencia, throughput), logs, trazas distribuidas (Jaeger, Zipkin). Integración: APIs avanzadas (GraphQL, gRPC), sistemas de mensajería (Kafka, RabbitMQ). Calidad: evaluación de trade-offs (rendimiento vs. mantenibilidad), refactoring arquitectónico. Prácticas: diseño e implementación de un sistema escalable (ejemplo: plataforma de streaming), uso de herramientas modernas.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 40,
    name: "Arquitectura de Computadoras",
    info: "Introducción a la arquitectura de computadoras avanzada: evolución de arquitecturas (CISC, RISC), comparación de paradigmas. Componentes de la CPU: pipeline (etapas, riesgos: datos, control, estructurales), predicción de saltos, ejecución fuera de orden. Jerarquía de memoria: caché (niveles, mapeo: directo, asociativo), optimización de acceso (prefetching, locality), memoria virtual avanzada. Paralelismo: arquitecturas multi-core, hyper-threading, GPUs, ejemplos (Intel, ARM). Interconexión: buses (PCIe, USB), redes en chip (NoC). Sistemas embebidos: características, diseño de bajo consumo, ejemplos (Raspberry Pi, Arduino). Herramientas: simulación de arquitecturas (gem5, QEMU), análisis de rendimiento (benchmarks). Prácticas: diseño de un procesador simple en un simulador, optimización de código para caché.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 41,
    name: "Parseo y Generación de Código",
    info: "Introducción a los compiladores: estructura (análisis léxico, sintáctico, semántico, optimización, generación de código), ejemplos de compiladores (GCC, LLVM). Análisis léxico: definición de tokens, autómatas finitos, herramientas (Lex, Flex), implementación de un lexer. Análisis sintáctico: gramáticas libres de contexto, parsers top-down (descendente recursivo), bottom-up (LR, LALR), herramientas (Yacc, Bison). Tablas de símbolos: estructura, manejo de ámbitos, resolución de nombres. Análisis semántico: verificación de tipos, chequeo de declaraciones, generación de árboles sintácticos abstractos (AST). Optimización: transformaciones (eliminación de código muerto, inlining), análisis de flujo de datos. Generación de código: traducción a código intermedio (IR como LLVM), generación de código máquina, ejemplos en ensamblador. Prácticas: desarrollo de un compilador simple para un lenguaje minimalista.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 42,
    name: "Ejercicio Profesional",
    info: "Introducción al ejercicio profesional en informática: roles y responsabilidades del profesional, ética en la profesión (códigos de ética ACM, IEEE). Aspectos legales: propiedad intelectual (patentes, derechos de autor), licencias de software (GPL, MIT), protección de datos (GDPR, leyes locales). Contratos: tipos (laborales, consultoría), cláusulas comunes, negociación. Gestión de carrera: habilidades blandas (comunicación, trabajo en equipo), construcción de portafolio, entrevistas técnicas. Problemáticas éticas: privacidad, sesgos en IA, impacto social de la tecnología, casos de estudio (Cambridge Analytica, deepfakes). Prácticas: análisis de casos reales, redacción de contratos simulados, debates sobre ética tecnológica.",
    infoUrl: null,
    area: "APyS",
    hsWeekly: 3,
    hsTotal: 48,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 43,
    name: "Tecnología y Sociedad",
    info: "Introducción a la relación entre tecnología y sociedad: impacto histórico (revolución industrial, era digital), teorías sociológicas (determinismo tecnológico, constructivismo). Tecnología y ética: dilemas (privacidad, automatización, vigilancia), responsabilidad del desarrollador, principios éticos en diseño. Impacto social: brecha digital, inclusión tecnológica, sostenibilidad (residuos electrónicos, consumo energético). Transformación del trabajo: automatización, gig economy, habilidades del futuro. Políticas públicas: regulación de tecnología (IA, datos personales), estándares internacionales. Prospectiva: tendencias emergentes (IoT, biotecnología), análisis de escenarios futuros. Prácticas: investigación de un tema (ejemplo: IA y empleo), presentación de propuestas para mitigar impactos negativos.",
    infoUrl: null,
    area: "APyS",
    hsWeekly: 3,
    hsTotal: 48,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },

  // Optativas y Electivas específicas
  {
    id: 44,
    name: "Computación Gráfica",
    info: "Introducción a la computación gráfica: definición, aplicaciones (videojuegos, visualización científica, cine). Fundamentos matemáticos: vectores, matrices, transformaciones 2D y 3D (traslación, rotación, escalado). Modelado: representación de objetos (mallas poligonales, curvas Bézier, NURBS), estructuras de datos para gráficos. Renderizado: pipeline gráfico (vertex processing, rasterización, fragment processing), iluminación (modelo de Phong, sombras), texturas (mapeo, filtrado). Algoritmos: trazado de rayos (ray tracing), eliminación de superficies ocultas (z-buffer), recorte (Cohen-Sutherland). Herramientas: OpenGL, WebGL, bibliotecas (Three.js). Prácticas: implementación de un renderizador simple, creación de una escena 3D interactiva.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 45,
    name: "Minería de Datos",
    info: "Introducción a la minería de datos: definición, relación con big data y machine learning, proceso (CRISP-DM). Preprocesamiento: limpieza de datos, manejo de valores faltantes, normalización, reducción de dimensionalidad (PCA). Algoritmos de clasificación: árboles de decisión, k-NN, SVM, evaluación (precisión, recall, F1). Algoritmos de clustering: k-means, jerárquico, DBSCAN, métricas de calidad (silhouette). Reglas de asociación: algoritmo Apriori, medidas (soporte, confianza, lift), ejemplos (análisis de mercado). Herramientas: Weka, Python (scikit-learn, pandas), visualización de resultados (Matplotlib). Aplicaciones: análisis de patrones, predicción de comportamiento, detección de anomalías. Prácticas: minería de un conjunto de datos real (ejemplo: ventas, redes sociales).",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 46,
    name: "Desarrollo de Aplicaciones Móviles",
    info: "Introducción al desarrollo móvil: plataformas (Android, iOS), diferencias con desarrollo web/desktop. Entorno Android: arquitectura (Linux kernel, ART, SDK), herramientas (Android Studio), componentes (Activities, Fragments, Intents). Entorno iOS: arquitectura (Cocoa Touch, Swift), herramientas (Xcode), componentes (View Controllers, Storyboards). Diseño de interfaces: principios de Material Design, guías de Apple HIG, layouts responsivos. Persistencia: almacenamiento local (SharedPreferences, SQLite), integración con APIs REST. Funcionalidades móviles: sensores (GPS, acelerómetro), notificaciones push, multimedia (cámara, audio). Publicación: proceso de deployment (Google Play, App Store), firma de aplicaciones. Prácticas: desarrollo de una app completa (ejemplo: app de notas), pruebas en emuladores y dispositivos físicos.",
    infoUrl: null,
    area: "ISBDySI",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 47,
    name: "Inteligencia Artificial",
    info: "Introducción a la inteligencia artificial: definición, historia (Turing, Dartmouth), ramas (IA simbólica, conexionista, híbrida). Búsqueda: algoritmos no informados (DFS, BFS), informados (A*, heurísticas), aplicaciones (juegos, planificación). Representación del conocimiento: lógica proposicional y de predicados, redes semánticas, ontologías. Aprendizaje automático: supervisado (regresión, clasificación: KNN, SVM), no supervisado (clustering: k-means), redes neuronales básicas (perceptrón, backpropagation). Procesamiento de lenguaje natural: tokenización, POS tagging, modelos básicos (n-gramas). Visión por computadora: detección de bordes, segmentación, reconocimiento de patrones. Herramientas: Python (TensorFlow, PyTorch), frameworks de IA. Prácticas: implementación de un agente de búsqueda y un clasificador simple.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 48,
    name: "Sistemas Embebidos",
    info: "Introducción a los sistemas embebidos: definición, características (bajo consumo, tiempo real), aplicaciones (IoT, automóviles). Hardware: microcontroladores (Arduino, ESP32), sensores y actuadores, interfaces (I2C, SPI, UART). Software: programación en C/C++, sistemas operativos embebidos (FreeRTOS), drivers básicos. Diseño: especificación de requisitos, integración hardware-software, optimización de recursos. Comunicación: protocolos (MQTT, Bluetooth), redes de sensores. Tiempo real: tareas periódicas, interrupciones, planificación en sistemas embebidos. Prácticas: desarrollo de un proyecto (ejemplo: monitor de temperatura), programación y prueba en hardware real.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 49,
    name: "Seminario de Actualización Tecnológica",
    info: "Exploración de temas emergentes en informática: tendencias actuales (IA generativa, computación cuántica, 5G), impacto en la industria y la sociedad. Metodología: análisis de artículos científicos, white papers, conferencias recientes (ejemplo: NeurIPS, SIGCOMM). Actividades: lectura crítica, debates en clase, presentación de resúmenes. Casos de estudio: análisis de tecnologías disruptivas (blockchain, edge computing), evaluación de su viabilidad. Invitados: charlas de expertos en el campo. Proyecto final: investigación de un tema elegido, presentación oral y escrita de resultados. Evaluación: participación, calidad del análisis, claridad en la comunicación.",
    infoUrl: null,
    area: "Otros",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },

  // Tecnicatura en programación
  {
    id: 101,
    name: "Matemática para Informática I",
    info: "Lógica proposicional y de primer orden: proposiciones, operaciones lógicas, equivalencias, tablas de verdad, leyes lógicas, simplificaciones. Cuantificadores: universal y existencial, negación, formalización. Razonamiento deductivo: reglas de inferencia, técnicas de prueba. Teoría básica de conjuntos: pertenencia, inclusión, operaciones, propiedades, diagramas de Venn. Aplicaciones en informática: algoritmos y estructuras discretas.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 102,
    name: "Introducción a Lógica y Problemas Computacionales",
    info: "Introducción a la informática: hardware vs. software, historia, futuros (IA, cuántica). Historia del software y lenguajes: paradigmas (imperativo, OO, funcional). Lógica proposicional: conectivos, razonamientos, representación formal. Programas: entornos de desarrollo y ejecución. Programación imperativa: comandos, sensores, estructuras de control, división en subtareas, estructuración.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 103,
    name: "Organización de Computadoras I",
    info: "Historia de la computación. Computadora: modelo Von Neumann. Representación binaria: numéricos (decimal, binario), enteros, racionales, errores. Alfanumérica: ASCII, Unicode. Aritmética binaria: suma, resta, flags. Lógica digital: álgebra de Boole, compuertas, circuitos combinacionales. Unidades: ALU, registros, memoria, E/S, buses. Lenguaje de máquina y ensamblador: instrucciones, ensambladores, compiladores. Microprocesadores y embebidos.",
    infoUrl: null,
    area: "ASOyR",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 104,
    name: "Taller de Lenguajes de Marcado y Tecnologías Web",
    info: "Lenguajes de marcado: definición, propósito. Markdown: sintaxis básica. XML y HTML: estructura, etiquetas semánticas HTML5, formularios, multimedia. CSS: selectores, propiedades, diseño responsive. Generación estática: generadores como Jekyll. Generación dinámica: servidores web, conceptos de backend. Prácticas: sitios web con HTML/CSS.",
    infoUrl: null,
    area: "TC",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 105,
    name: "Programación Estructurada",
    info: "Valores y expresiones: tipos básicos. Estado: variables, ámbito. Terminación y parcialidad. Precondiciones: desarrollo robusto. Programación estructurada: funciones, procedimientos, modularidad. Resolución de problemas: algoritmos básicos. Tipos estructurados: arreglos, registros. Prácticas: implementación en C o Python.",
    infoUrl: null,
    area: "AyL",
    hsWeekly: 6,
    hsTotal: 96,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 106,
    name: "Matemática para Informática II",
    info: "Lógica de primer orden: cuantificadores, predicados. Relaciones binarias: orden, equivalencia, funcionales, propiedades. Diagramas de Hasse. Inducción: demostraciones, aplicaciones. Análisis combinatorio: conteo, permutaciones, combinaciones.",
    infoUrl: null,
    area: "CB",
    hsWeekly: 4,
    hsTotal: 64,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
  {
    id: 107,
    name: "Materia UNAHUR: Abordaje de situaciones sociales complejas",
    info: "Complejidad (Morin): sistemas abiertos, incertidumbre. Filosofía (Leocata): individuo y comunidad. Redes sociales: exclusión/inclusión. Droga: factores, modelos asistenciales. Doctrina Social y Papa Francisco: justicia, bien común. Redes como respuesta. Prácticas: análisis de casos.",
    infoUrl: null,
    area: "Gral",
    hsWeekly: 2,
    hsTotal: 32,
    code: null,
    isPlaceholder: false,
    parentOptionId: null,
  },
];
